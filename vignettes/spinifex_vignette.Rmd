---
title: "spinifex vignette"
author: "Nicholas S Spyrison"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!-- #Example vignette: 
https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   # code
  include    = TRUE,   # plots
  results    = "hide", # text: "hide", "show"
  eval       = TRUE,   # chunk
  message    = FALSE,
  warning    = FALSE,
  error      = FALSE,
  collapse   = TRUE,
  comment    = "#>",
  fig.height = 6,
  fig.width  = 9,
  fig.align  = "center",
  cache      = FALSE
)

library(spinifex)
library(tourr)
library(GGally)
```

# Introduction

Numeric multivariate data is ubiquitous and viewing data within data-space (rather than summarized as parameters or statistics) is a critical part of exploratory data analysis and the data analysis workflow in general. Viewing data that exists in more than 3 numeric dimensions quickly becomes complex. Linear projections of high dimensional spaces offers a scalable way to extend viewing these data-spaces as the dimenstion of the data increase. Viewing many of such projections is a technique know as *tours*.

The package `spinifex` allows the application of manual tours, where a selected variable is rotated fully into and out of the give projection basis. It's also compatible with other tours from the tourr package and extends graphic display to `plotly` and `gganimate`.


## Tours

In short, tours are class of dynamic orthogonal (linear) projections that embed $p-$dimensional variate space ($\textbf{X} \in \mathbb{R}^{p}$) down to $d$ dimensions and observes many such projections as $p-$ space is rotated. Tours are useful in identify clustering, outliers, and structure held within numeric multivariate data. We focus on the application of the manual tour in this document. A wider application of tours can be found at: [cran.r-project.org/web/packages/tourr/tourr.pdf](https://cran.r-project.org/web/packages/tourr/tourr.pdf).

This concept is illustrated well with the anecdote of shadow puppets. Suppose a bar stool is held in front of a light source. This is a linear projection of a 3D object (bar stool) down to 2D (it's shadow). If we observe the shadow change over time as the bar stool is rotated, we are watching a 3- to 2D tour. Some projections may not convey much information (the seat may only cast a circular shadow), but as we watch the stool rotate our visual interpretation quickly understands the geometry of the object. The same is true for tours, each view holds some information, and a better understanding of the structure is gained over time. 

## Notation

- *n* - number of observations in the data
- *p* - number of variables/dimensions in the data
- *d* - number of dimensions in the projection, $d \leq p$, typically 2
- *basis* - $[p,~d]$ orthonormal matrix, orientation of the variables projecting from $p-$ to $d-$space
- *refference frame* - graphical display of the basis, line segments on a unit circle, showing how each variable contributes to the projection space
- *manip var* - the selected variable to manipulate into and out of the projection, highlighted in blue below

**TODO: CONTINUE EDITING HERE.**

# Usage

## Example 1 - Rotate arbitrary basis

For this example, we'll be using the flea data set. It consists of 74 observations of wine across 6 numeric variables and a categorical variable of the species of flea beetle (with 3 levels).

Suppose we want to perform a rotation on, `aded2`, one dimension of the 6-dimensional data. We'll initialize a random basis and then view the manipulation space.


```{r}
flea_std <- tourr::rescale(tourr::flea[,-7]) # species of grape removed.

str(flea_std)
flea_rb <- tourr::basis_random(n = ncol(flea_std))
view_manip_space(basis = flea_rb, manip_var = 5, labels = colnames(flea_std))
```

<!-- I like to think of the basis as piece of paper that maps p dimension down to 2. The manipulation type (alternatively theta) is the angle of the on this basis plane between (1, 0) and the manipulation variable's vector in, our case we select 'head'. -->

<!-- In order to rotate the data object we effectively rotate this map. Imagine gluing the bottom of a pen to the (0, 0) origin of the paper. By rotating the pen about the origin we rotate the whole paper.  -->

Use `proj_data()` to rotate `data` at the current orientation `basis`, by manipulating `manip_var` of the `manip` type, for a sequence of 'phi' `from` through `to` by an increment `by`.

Optionally we can specify:

* `manip_type`, "horizontal", "vertical", or "radial", controlling the the angle w.r.t. the basis' plane to rotate the variable.
* `phi_from`, the start angle to rotate the variable from, in the z direction of the basis plane.
* `Phi_to`, the end angle to rotate the variable to, in the z direction of the basis plane.
* `n_slides`, the number of increments to calculate phi between the from and to values.


```{r}
# mtour <- manual_tour(basis = rb, manip_var = 1)
# sshow <- array2df(tour = mtour, data = wine_std)
# render_plotly(slides = sshow)
```


## Example 2 - Rotating a glyph map

TODO: is this the target??
```{r}

nasa <- GGally::nasa

temp.gly <-
  GGally::glyphs(nasa, "long", "day", "lat", "surftemp", height = 2.5)
glyph1 <-
  ggplot(temp.gly, aes(gx, gy, group = gid)) +
  GGally::add_ref_lines(temp.gly, color = "grey90") +
  GGally::add_ref_boxes(temp.gly, color = "grey90") +
  geom_path() +
  theme_bw() +
  labs(x = "", y = "")

glyph1
```



```{r}
# Initialize
nasa_std <- cbind(GGally::nasa[c("x", "y")], tourr::rescale(nasa[c("day", "surftemp")]))
bas <- tourr::basis_init(ncol(nasa_std), 2)

# Horizontal roation
m_sp_x = create_manip_space(basis = bas, manip_var = 3)
rot_mat_x <- rotate_manip_space(manip_space = m_sp_x, theta = 0, phi = pi/6)
rot_x <- data.frame(as.matrix(nasa_std) %*% as.matrix(rot_mat_x))

# Vertical roation
m_sp_y = create_manip_space(basis = bas, manip_var = 4)
rot_mat_y <- rotate_manip_space(manip_space = m_sp_y, pi/2, pi/6)
rot_y <- data.frame(as.matrix(nasa_std) %*% as.matrix(rot_mat_y))

library(dplyr)
rot_xy <- bind_cols(rot_x, rot_y)
rot_xy <- select(rot_xy, X1, X3) %>% rename(x=X1, y=X3)

ggplot(rot_xy, aes(x=x, y=y)) + geom_point(size=0.3)
```

```{r}
# # Horizonal manual rotation
# tour_x <- manual_tour(basis = bas, manip_var = 3, theta = 0)
# tourdf_x <- array2df(array = tour_x, data = nasa_std)
# # render_plotly(slides = slides_x) # Way too heavy
# 
# # Vertical manual rotation
# tour_y <- manual_tour(basis = bas, manip_var = 4, theta = 90)
# tourdf_y <- array2df(array = tour_y, data = nasa_std)
# # render_plotly(slides = slides_y) # Way too heavy
```



```{r}
# nasa2 <- cbind(
#   nasa[c("long", "day", "lat", "surftemp")],
#   adj_day <- #x, rotated day
#     proj_rday$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ],
#   adj_surftemp <- #y, rotated surftemp
#     proj_rsurftemp$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ]
# )
# 
# temp.gly2 <-
#   GGally::glyphs(nasa2, "long", "adj_day", "lat", "adj_surftemp", height = 2.5)
# glyph2 <-
#   ggplot(temp.gly2, ggplot2::aes(gx, gy, group = gid)) +
#   GGally::add_ref_lines(temp.gly, color = "grey90") +
#   GGally::add_ref_boxes(temp.gly, color = "grey90") +
#   geom_path() +
#   theme_bw() +
#   labs(x = "", y = "")
# 
# gridExtra::grid.arrange(glyph1, glyph2, ncol=2)
```

## Example 3 - Rotation after holes guided tour

Manual tours are often employed after an interesting feature has been identified. The local area around PCA for example might be interesting to explore. Alternatively we can use (stochastic) gradient decent on some objective function and start from the resulting basis. Let's do just that, optimize a Holes tour using the packages `tourr`:

```{r}
# flea_std <- tourr::rescale(tourr::flea[,1:6])
# fpath    <- tourr::save_history(flea_std, tourr::guided_tour(tourr::holes))
# 
# play_tour_path(tour_path = fpath, data = flea_std)
```

From there, we can explore the local structure one variable at a time.

```{r}
# fbasis  <- matrix(as.numeric(fpath[,, dim(fpath)[3]]), ncol = 2)
# ftour   <- manual_tour(basis = fbasis, manip_var = 4)
# ftourdf <- array2df(tour = ftour, data = flea_std)
# render_plotly(slides = ftourdf)
```


# Conclusion

## Summary

`spinifex` applies manual tours and integrates with `tourr`, extending graphic diplay to `plotly` and `gganimate`. This is part of an import technique collectively known as $tours$. Tours

## Namesake 

The name 'spinifex' comes from the [spinifex hopping mouse](https://en.wikipedia.org/wiki/Spinifex_hopping_mouse), a nocturnal dessert mouse common to arid zones in central and western Australia. As to it's relation to this work, in the words of Di "it spins, it hops and needs a 'mouse'."


## Acknowledgement

Thanks to Prof. Dianne Cook for focus, namesake, and the ground work underpinning this work. Thanks to Dr. Ursula Laa for use-cases and application.



