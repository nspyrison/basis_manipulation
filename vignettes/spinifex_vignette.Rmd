---
title: ""
author: "Nicholas S Spyrison"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!-- #EXAMPLE: https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   # code
  include    = TRUE,   # plots
  results    = "hide", # text: "hide", "show"
  eval       = TRUE,   # chunk
  message    = FALSE,
  warning    = FALSE,
  error      = FALSE,
  collapse   = TRUE,
  comment    = "#>",
  fig.height = 6,
  fig.width  = 9,
  fig.align  = "center",
  cache      = FALSE
)
```

<!-- # Overview -->

## Motivation

Data sets commonly contain many dimensions (numeric variables). What happens to the visualization of the data as we get above 3 or so dimensions? Adding aesthetics such as point size or color, can afford another dimension or two, but the extension is quite limited. Too often data-space visualizations are abandoned either for plotting in model and parameter-space ($ie.$ residual plots and parallel coordinate plots) or abandoned altogether for tabular statistics [@Wicham_removing_YYYY]. Yet looking at statistics alone can leave us with quite the wrong picture, which becomes obvious when plotting data-space [@anscobes_Q; @dino-data_yyyy]. It's clear that we should try to extend graphics in these spaces as far as possible. Dimensionality reduction techniques use sub-space embedding to project a $p$-dimensional object onto a $d$-dimensional subspace, typically with $d = 2$ and $p \gt d$.

## Methodology

There are two major branches of dimensionality reduction techniques: linear and non-linear. Consider a simple XY coordinate grid. Linear transformations include rotation, shear, and scaling component, $eg.$ anything that allows parallel lines on the original grid to stay parallel. Any transformation that doesn't preserve parallel lines is non-linear including, warping, waving, folding etc.

Traditionally, linear techniques including principal component analysis (PCA), correspondence analysis (CCA), or other single value decomposition (SVD) techniques have been used to approximate high dim spaces down to 2 or 3-d. However, even when such techniques help to order dimension to describe the most variation in a given number of dimension, variation is necessarily lost in the $p - d$ components not plotted.

More recently, non-linear techniques such as t-distributed stochastic neighbor embedding (t-SNE) and Sammon mapping have seen a rise in popularity. These techniques can make for astonishing plots showing distinctions and likeness across groups, but can suffer from over-fitting and lose inter-operability back to the original dimensions. They make for stark graphics and can be nice litmus test for outlier identification, yet losing a map back to the original dimensions is a non-starter for most quantitative pursuits.

We purpose the use of linear dimensionallity reduction techniques known as touring. With touring we maintain the operability to the original variable space, while not discarding any components to avoid losing information held within the data.

## Touring

In short, touring projects a $p$-dimensional data object down to a lower d-dimensional embedding (2d in the case of standard computer monitors). The low dimensional projection is then observed as the p-dimensional object is rotated in p-space. 

This concept can be illustrated succinctly by anecdote of shadow puppets. A 3-d object (hand) blocks a light source that casts a shadow (linear projection) onto a 2-d screen. Suppose a bar stool hinders a light source such that shadow is a circle. while the object is stationary the shadow circular shade does not give conclusive information about the shape of the object. However, rotation of the bar stool in 3-dimensions quickly and intuitively conveys this information. This is the premise behind touring. In the same way, information and interesting profiles describing high dimensional datasets can be observed by watching projections of linear combinations of higher dimensions as the data rotates.

Touring was originally suggested by Asimov et. al. in 1985[@Asimov et. al. 1985]. In which he purposed grand tour, essentially watching a 2-d projection of a random  walk in p-space.The method of rotating a data object is essentially four-fold[@Buja et. al. 2004]: 'grand tour' -- a random forest selection of dimension and direction, predefined path -- such as rotating through the full range of each variable in order, a 'little tour', data-defined path -- using stochastic gradient descent on some objective function, and manual control -- the selection of a particular variable, degree, and magnitude of change. 

SITE TOURR AND EXPLAIN WHAT SPINIFEX DOES [here](https://cran.r-project.org/web/packages/tourr/tourr.pdf).



# Code examples

## Example 1 - Rotate arbitrary basis

For this example we'll be using the wine data set. It consists of 178 observations of wine across 13 numeric variables and a categorical variable of type of grape (with 3 levels). 

Suppose we want to perform a rotation on one dimensions of the 6-dimensional data.  

In order to rotate a dimension in p-space we need the following arguments: 

* `data`, [n, p] matrix, or data frame of numeric columns.
* `basis`, [p, d=2] matrix, a linear combination of dimensions mapping to 2-D.
* `manip_var`, name or number of the dimension to rotate.

Flea is the data we want to rotate. We initialize a random basis and then view it. Later we'll manipulate the variable 'head'.

Load the data and select a random basis with `basis_random(p)`. View the basis in p-space with `view_basis(basis, data)`, where data is optional, but adds the dimension names.

```{r}
library(spinifex)
library(tourr)
# setting seed doens't make tourr reproducible.

data("wine") #dim(wine): 178x14
wine_std <- tourr::rescale(wine[,-1]) # Type of grape removed.

rb <- tourr::basis_random(n = ncol(wine_std))
view_basis(basis = rb, labels = colnames(wine_std))
```

<!-- I like to think of the basis as piece of paper that maps p dimension down to 2. The manipulation type (alternatively theta) is the angle of the on this basis plane between (1, 0) and the manipulation variable's vector in, our case we select 'head'. -->

<!-- In order to rotate the data object we effectively rotate this map. Imagine gluing the bottome of pen to the (0, 0) origin of the paper. By rotating the pen about the origin we rotate the whole paper.  -->

Use `proj_data()` to rotate `data` at the current orientation `basis`, by manipulating `manip_var` of the `manip` type, for a sequence of 'phi' `from` through `to` by an increment `by`.

Optionally we can specify:

* `manip_type`, "horizontal", "vertical", or "radial", controlling the the angle w.r.t. the basis' plane to rotate the variable.
* `phi_from`, the start angle to rotate the variable from, in the z direction of the basis plane.
* `Phi_to`, the end angle to rotate the variable to, in the z direction of the basis plane.
* `n_slides`, the number of increments to calculate phi between the from and to values.

Watch the projection, via `slideshow()`, coloring observations by their species.

```{r}
mtour <- manual_tour(basis = rb, manip_var = 1)
  # manual_tour calls tourr::orthonormalise() that travis CI complains about as it isn't on the CRAN version. Added refrence to the GH version of tourr with Nick T.
sshow <- create_slides(tour = mtour, data = wine_std)
(wine_rss <- render_slideshow(slides = sshow))
```


## Example 2 - Rotating a glyph map

```{r}
library(GGally)
nasa <- GGally::nasa

temp.gly <-
  GGally::glyphs(nasa, "long", "day", "lat", "surftemp", height = 2.5)
glyph1 <-
  ggplot(temp.gly, aes(gx, gy, group = gid)) +
  GGally::add_ref_lines(temp.gly, color = "grey90") +
  GGally::add_ref_boxes(temp.gly, color = "grey90") +
  geom_path() +
  theme_bw() +
  labs(x = "", y = "")

glyph1
```



```{r}
# 
# gg1<-ggplot(nasa_sub, aes(x=x+day/2, y=y+surftemp/2)) + geom_point(size=0.3)
# 
# nasa_std <- cbind(nasa[c("x", "y")], 
#                    tourr::rescale(nasa[c("day", "surftemp")])
# )
# b2 <- create_identity_basis(p = ncol(nasa_sub))
# 
# # Horizontal component:
# m_sp = create_manip_space(basis = basis, manip_var = 3)
# rot_mat <- rotate_manip_space(manip_space = m_sp, theta = 0, phi = pi/6)
# nasa_std_rot_x <- data.frame(as.matrix(nasa_std) %*% as.matrix(rot_mat))
# 
# # Vertical
# manip_space = create_manip_space(basis = basis, manip_var = 4)
# rot_mat <- rotate_manip_space(manip_space, pi/2, pi/6)
# nasa_sub_rot_y <- data.frame(as.matrix(nasa_sub) %*% as.matrix(rot_mat))
# nasa_sub_rot <- bind_cols(nasa_sub_rot_x, nasa_sub_rot_y) %>%
#   select(x, y1) %>%
#   rename(x=x, y=y1)
# 
# gg2<-ggplot(nasa_sub_rot, aes(x=x, y=y)) + geom_point(size=0.3)

# # Perform a horizonal rotation on a glyphmap
# b2 = create_identity_basis(p = ncol(nasa_sub))
# mtour2 <- manual_tour(basis = b2, manip_var = 3, manip_type = "horizontal")
# sshow2 <- create_slides(tour = mtour2, data = nasa2_std)
# (nasa_hss <- render_slideshow(slides = sshow2))
# 
# 
# # Perform a Vertical rotation on a second variable of a glyphmap
# rb3 <- tourr::basis_random(n = ncol(nasa_std))
# mtour3 <- manual_tour(basis = rb3, manip_var = 4, manip_type = "vertical")
# sshow3 <- create_slides(tour = mtour3, data = nasa_std)
# (nasa_vss <- render_slideshow(slides = sshow3))


```



```{r}
# nasa2 <- cbind(
#   nasa[c("long", "day", "lat", "surftemp")],
#   adj_day <- #x, rotated day
#     proj_rday$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ],
#   adj_surftemp <- #y, rotated surftemp
#     proj_rsurftemp$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ]
# )
# 
# temp.gly2 <-
#   GGally::glyphs(nasa2, "long", "adj_day", "lat", "adj_surftemp", height = 2.5)
# glyph2 <-
#   ggplot(temp.gly2, ggplot2::aes(gx, gy, group = gid)) +
#   GGally::add_ref_lines(temp.gly, color = "grey90") +
#   GGally::add_ref_boxes(temp.gly, color = "grey90") +
#   geom_path() +
#   theme_bw() +
#   labs(x = "", y = "")
# 
# gridExtra::grid.arrange(glyph1, glyph2, ncol=2)
```



## Example 3 - Rotation after holes guided tour

Manual tours are often employed after an interesting feature has been identified. The local area around PCA for example might be interesting to explore. Alternatively we can use (stochastic) gradient decent on some objective function and start from the resulting basis. Let's do just that, optimize a Holes tour using the packages `tourr`:

```{r}
flea_std <- tourr::rescale(spinifex::flea[,1:6])
fpath <- tourr::save_history(flea_std, tourr::guided_tour(tourr::holes))

play_tour(tour = fpath, data = flea_std)
```

From there, we can explore the local structure one variable at a time.

```{r}
fbasis <- matrix(as.numeric(fpath[,, dim(fpath)[3]]), ncol = 2)

ftour <- manual_tour(basis = fbasis, manip_var = 4)
fslides <- create_slides(tour = ftour, data = flea_std)
render_slideshow(slides = fslides)
```

```{r}
abbreviate(colnames(flea_std),3)

# tr1_tour <- manual_tour(basis = h_basis, manip_var = 1)
# tr1_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# tr2_tour <- manual_tour(basis = h_basis, manip_var = 2)
# tr2_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# hed_tour <- manual_tour(basis = h_basis, manip_var = 3)
# hed_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad1_tour <- manual_tour(basis = h_basis, manip_var = 4)
# ad1_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad2_tour <- manual_tour(basis = h_basis, manip_var = 5)
# ad2_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad3_tour <- manual_tour(basis = h_basis, manip_var = 6)
# ad3_sshow <- create_slides(data = flea_std, tour = tr1_tour)
```


```{r}
# render_slideshow(tr1_sshow)
# render_slideshow(tr2_sshow)
# render_slideshow(hed_sshow)
# render_slideshow(ad1_sshow)
# render_slideshow(ad2_sshow)
# render_slideshow(ad3_sshow)
```


# Conclusion

## Summary

[RECAP WHAT PKG HELPS US DO, nanier for example:]
The tools in `naniar` help us identify where missingness is, while maintaining a tidy workflow. We care about these mechanisms or these patterns because they can help us understand potential mechanisms, such as equipment failures, and then identify possible solutions based upon this evidence.

## Namesake 

The name 'spinifex' comes from the [spinifex hopping mouse](https://en.wikipedia.org/wiki/Spinifex_hopping_mouse), a nocturnal dessert mouse common to arid zones in central and western Australia. As to it's relation to this work, in the words of Di "it spins, it hops and needs a 'mouse'."


## Acknowledgement

Thanks to Prof. Dianne Cook for focus, namesake, and the ground work underpinning this work. Thanks to Dr. Ursula Laa for use-cases and application.

## References
<!-- Monash prefers APA -->
<!-- citation(package = "tourr") -->
<!-- citation(package = "GGally") -->
- Cook, D., & Buja, A. (1997). Manual Controls for High-Dimensional Data Projections. Journal of Computational and Graphical Statistics, 6(4), 464–480. https://doi.org/10.2307/1390747
- Wickham, H., Cook, D., & Hofmann, H. (2015). Visualizing statistical models: Removing the blindfold: Visualizing Statistical Models. Statistical Analysis and Data Mining: The ASA Data Science Journal, 8(4), 203–225. https://doi.org/10.1002/sam.11271
- Dianne Cook and Hadley Wickham (NA). tourr: Implement Tour Methods in R Code. R package version 0.5.5.9000. https://github.com/ggobi/tourr
- Barret Schloerke, Jason Crowley, Di Cook, Francois Briatte, Moritz Marbach,
Edwin Thoen, Amos Elberg and Joseph Larmarange (2017). GGally: Extension to
'ggplot2'. R package version 1.3.2. https://CRAN.R-project.org/package=GGally



