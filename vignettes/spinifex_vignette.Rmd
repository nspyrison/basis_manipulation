---
title: ""
author: "Nicholas S Spyrison"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!-- #EXAMPLE: https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   # code
  include    = TRUE,   # plots
  results    = "hide", # text: "hide", "show"
  eval       = TRUE,   # chunk
  message    = FALSE,  # messages
  warning    = FALSE,  # warnings
  error      = FALSE,  # errors
  collapse   = TRUE,
  comment    = "#>",
  fig.height = 6,
  fig.width  = 9,
  fig.align  = "center",
  cache      = FALSE
)
```

# Overview

## Motivation

Datasets commonly contain many (p>3) dimensions (numeric variables). As pointed out by Wickham et. al.[@Wickham et. al. YYYYY] Numeric aggregation and parametric estimation is scalable as the number of dimensions increase. Meanwhile visualization tends to shift towards depiction of model spaces and parameter space (think residual or parallel coordinate plots) which can scale with some dimensionality. Yet, visuals in data-space often fall by the wayside, especially when trying to illustrate more than 3 dimensions. If not all together abandoned, sub-optimal techniques are commonly employed.

## Alternateives

Traditionally, component analysis (PCA), correspondence analysis (CCA), or other single value decomposition (SVD) techniques have been used to approximate high dim spaces in 2 or 3-d. However, doing so requires an unsatifactory loss of information of the discarded linear combinations.

More recently, t-distributed stochastic neighbor embedding (t-SNE), Sammon mapping, and other non-linear transformations have seen a rise in popularity. These techniques can make for astonishing plots showing distinctions and likeness between groups, but can suffer from over-fitting (potentially resulting in false groupings) and lose inter-operability back to the original dimensions, a non-starter for many acemdemic persuits.

We suggest the use of linear methods that allow for the unique variation to be preserved and explorable as long as possible, namely, through the use of a method known as touring.

## Tour methodology

In short, touring projects a p-dimensional data object down to a lower d-dimensional embedding (2d in the case of standard computer monitors). The low dinemsonal projection is then observed as the p-dimensonal object is rotated in p-space. 

This concept can be illustrated succinctly by aniqdote of shadow puppets. A 3-d object (hand) blocks a light source that casts a shadow (linear projection) onto a 2-d screen. Suppose a bar stool hinders a light source such that shadow is a circle. while the object is stationary the shadow circlular shade does not give conclusive inforamation about the shape of the object. However, rotation of the bar stool in 3-dimensions quickly and intuitively conveys this information. This is the premise behind touring. In the same way, information and interesting profiles describing high dimensional datasets can be observed by watching projections of linear combinations of higher dimensions as the data rotates.

Touring was orginally suggested by Asimov et. al. in 1985[@Asimov et. al. 1985]. The Orginal suggestion was called a grand tour, escentially watching a 2-d projection of a random  walk in p-space.The method of rotating a data object is essentially four-fold[@Buja et. al. 2004]: 'grand tour' -- a random forest selection of dimension and direction, predifed path -- such as rotating through the full range of each variable in order, a 'little tour', data-defined path -- using stochastic gradient desenct on some objective function, and manual control -- the selection of a particular variable, degree, and manitude of change. 

SITE TOURR AND EXPLAIN WHAT SPINIFEX DOES [here](https://cran.r-project.org/web/packages/tourr/tourr.pdf).



# Code examples

## Example 1 - Rotate arbitrary basis

We'll use the flea data set. The data consists of 74 observations of 6 physical distance measurements of a flea-beetle belonging to 1 of 3 spices. This is analogous to the iris data set.

Suppose we want to perform a rotation on one dimensions of the 6-dimensional data.  

In order to rotate a dimension in p-space we need the following arguments: 

* `data`, [n, p] matrix, or data frame of numeric columns.
* `basis`, [p, d=2] matrix, a linear combination of dimensions mapping to 2-D.
* `manip_var`, name or number of the dimension to rotate.

Flea is the data we want to rotate. We initialize a random basis and then view it. Later we'll manipulate the variable 'head'.

Load the data and select a random basis with `basis_random(p)`. View the basis in p-space with `view_basis(basis, data)`, where data is optional, but adds the dimension names.

```{r}
library(spinifex)
devtools::install_github("ggobi/tourr", dependencies = TRUE) 
  # dev version of tourr
library(tourr)
set.seed(123) # I don't think seed makes tourr reproducible, but can't hurt.

data(wine)
wine_std <- tourr::rescale(wine[,-14]) # Type of grape removed.
 
rb <- tourr::basis_random(n = ncol(wine_std))
view_basis(basis = rb, labels = colnames(wine_std))
```

<!-- I like to think of the basis as piece of paper that maps p dimension down to 2. The manipulation type (alternatively theta) is the angle of the on this basis plane between (1, 0) and the manipulation variable's vector in, our case we select 'head'. -->

<!-- In order to rotate the data object we effectively rotate this map. Imagine gluing the bottome of pen to the (0, 0) origin of the paper. By rotating the pen about the origin we rotate the whole paper.  -->

Use `proj_data()` to rotate `data` at the current orientation `basis`, by manipulating `manip_var` of the `manip` type, for a sequence of 'phi' `from` through `to` by an increment `by`.

Optionally we can specify:

* `manip_type`, "horizontal", "vertical", or "radial", controlling the the angle w.r.t. the basis' plane to rotate the variable.
* `phi_from`, the start angle to rotate the variable from, in the z direction of the basis plane.
* `Phi_to`, the end angle to rotate the variable to, in the z direction of the basis plane.
* `n_slides`, the number of increments to calculate phi between the from and to values.

Watch the projection, via `slideshow()`, coloring observations by their species.

```{r}
mtour <- manual_tour(basis = rb, manip_var = 1) 
  # manual_tour calls tourr::orthonormalise() that travis CI complains about because it isn't in the tourr NAMESPACE. but it is for me. it this because Di made it public in the dev vers and Travis is grabbing the CRAN ver? Added github version in vignette.
sshow <- create_slides(tour = mtour, data = wine_std)
(wine_rss <- render_slideshow(slides = sshow))
```




## Example 2 - Rotating a glyph map

```{r}
data("weatherAUS")
str(weatherAUS)


temp.gly <-
  GGally::glyphs(nasa, "long", "day", "lat", "surftemp", height = 2.5)
glyph1 <-
  ggplot(temp.gly, aes(gx, gy, group = gid)) +
  GGally::add_ref_lines(temp.gly, color = "grey90") +
  GGally::add_ref_boxes(temp.gly, color = "grey90") +
  geom_path() +
  theme_bw() +
  labs(x = "", y = "")

glyph1
```



```{r}

gg1<-ggplot(nasa_sub, aes(x=x+day/2, y=y+surftemp/2)) + geom_point(size=0.3)

nasa_std <- cbind(nasa[c("x", "y")], 
                   tourr::rescale(nasa[c("day", "surftemp")])
)
b2 <- create_identity_basis(p = ncol(nasa_sub))

# Horizontal component:
m_sp = create_manip_space(basis = basis, manip_var = 3)
rot_mat <- rotate_manip_space(manip_space = m_sp, theta = 0, phi = pi/6)
nasa_std_rot_x <- data.frame(as.matrix(nasa_std) %*% as.matrix(rot_mat))

# Vertical
manip_space = create_manip_space(basis = basis, manip_var = 4)
rot_mat <- rotate_manip_space(manip_space, pi/2, pi/6)
nasa_sub_rot_y <- data.frame(as.matrix(nasa_sub) %*% as.matrix(rot_mat))
nasa_sub_rot <- bind_cols(nasa_sub_rot_x, nasa_sub_rot_y) %>%
  select(x, y1) %>%
  rename(x=x, y=y1)

gg2<-ggplot(nasa_sub_rot, aes(x=x, y=y)) + geom_point(size=0.3)

# # Perform a horizonal rotation on a glyphmap
# b2 = create_identity_basis(p = ncol(nasa_sub))
# mtour2 <- manual_tour(basis = b2, manip_var = 3, manip_type = "horizontal")
# sshow2 <- create_slides(tour = mtour2, data = nasa2_std)
# (nasa_hss <- render_slideshow(slides = sshow2))
# 
# 
# # Perform a Vertical rotation on a second variable of a glyphmap
# rb3 <- tourr::basis_random(n = ncol(nasa_std))
# mtour3 <- manual_tour(basis = rb3, manip_var = 4, manip_type = "vertical")
# sshow3 <- create_slides(tour = mtour3, data = nasa_std)
# (nasa_vss <- render_slideshow(slides = sshow3))


```



```{r}
#TODO: RESUME HERE:
nasa2 <- cbind(
  nasa[c("long", "day", "lat", "surftemp")],
  adj_day <- #x, rotated day
    proj_rday$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ],
  adj_surftemp <- #y, rotated surftemp
    proj_rsurftemp$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ]
)

temp.gly2 <-
  GGally::glyphs(nasa2, "long", "adj_day", "lat", "adj_surftemp", height = 2.5)
glyph2 <-
  ggplot(temp.gly2, ggplot2::aes(gx, gy, group = gid)) +
  GGally::add_ref_lines(temp.gly, color = "grey90") +
  GGally::add_ref_boxes(temp.gly, color = "grey90") +
  geom_path() +
  theme_bw() +
  labs(x = "", y = "")

gridExtra::grid.arrange(glyph1, glyph2, ncol=2)
```



## Example 3 - Rotation after holes guided tour

```{r, results='hide'}
data(flea)
flea_std <- tourr::rescale(flea[,1:6])

# Holes is unsupervised stochastic gradient descent maximizing whitespace 
#   in the middle of the projection.
# h_tour<- tourr::save_history(
#   flea_std, tourr::guided_tour(index = tourr::holes), max_bases = 25) 
# h_basis <- matrix(as.numeric(h_tour[,, dim(h_tour)[3]]), ncol = 2)
# 
# h_mtour <- manual_tour(basis = h_basis, manip_var = 4)
# cslides <- create_slides(tour = mtour, data = flea_std)
# render_slideshow(slides = cslides)
```

```{r}
abbreviate(colnames(flea_std),3)

# tr1_tour <- manual_tour(basis = h_basis, manip_var = 1)
# tr1_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# tr2_tour <- manual_tour(basis = h_basis, manip_var = 2)
# tr2_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# hed_tour <- manual_tour(basis = h_basis, manip_var = 3)
# hed_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad1_tour <- manual_tour(basis = h_basis, manip_var = 4)
# ad1_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad2_tour <- manual_tour(basis = h_basis, manip_var = 5)
# ad2_sshow <- create_slides(data = flea_std, tour = tr1_tour)
# ad3_tour <- manual_tour(basis = h_basis, manip_var = 6)
# ad3_sshow <- create_slides(data = flea_std, tour = tr1_tour)
```


```{r}
# render_slideshow(tr1_sshow)
# render_slideshow(tr2_sshow)
# render_slideshow(hed_sshow)
# render_slideshow(ad1_sshow)
# render_slideshow(ad2_sshow)
# render_slideshow(ad3_sshow)
```


# Conclusion

## Summary

[RECAP WHAT PKG HELPS US DO, nanier for example:]
The tools in `naniar` help us identify where missingness is, while maintaining a tidy workflow. We care about these mechanisms or these patterns because they can help us understand potential mechanisms, such as equipment failures, and then identify possible solutions based upon this evidence.

## Namesake 

The name 'spinifex' comes from the [spinifex hopping mouse](https://en.wikipedia.org/wiki/Spinifex_hopping_mouse), a nocturnal dessert mouse common to arid zones in central and western Australia. As to it's relation to this work, in the words of Di "it spins, it hops and needs a 'mouse'."


## Acknowledgement

Thanks to Prof. Dianne Cook for focus, namesake, and the ground work underpinning this work. Thanks to Dr. Ursula Laa for use-cases and application.

## References
<!-- Monash prefers APA -->
<!-- citation(package = "tourr") -->
<!-- citation(package = "GGally") -->
- Cook, D., & Buja, A. (1997). Manual Controls for High-Dimensional Data Projections. Journal of Computational and Graphical Statistics, 6(4), 464–480. https://doi.org/10.2307/1390747
- Wickham, H., Cook, D., & Hofmann, H. (2015). Visualizing statistical models: Removing the blindfold: Visualizing Statistical Models. Statistical Analysis and Data Mining: The ASA Data Science Journal, 8(4), 203–225. https://doi.org/10.1002/sam.11271
- Dianne Cook and Hadley Wickham (NA). tourr: Implement Tour Methods in R Code. Rpackage version 0.5.5.9000. https://github.com/ggobi/tourr
- Barret Schloerke, Jason Crowley, Di Cook, Francois Briatte, Moritz Marbach,
Edwin Thoen, Amos Elberg and Joseph Larmarange (2017). GGally: Extension to
'ggplot2'. R package version 1.3.2. https://CRAN.R-project.org/package=GGally



