---
title: ""
author: "Nicholas S Spyrison"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!-- #EXAMPLE: https://github.com/njtierney/naniar/blob/master/vignettes/getting-started-w-naniar.Rmd -->
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   #code
  include    = TRUE,   #plots
  results    = "hide", #text
  message    = FALSE,  #messages
  warning    = FALSE,  #warnings
  error      = FALSE,  #errors
  collapse   = TRUE,
  comment    = "#>",
  fig.height = 6,
  fig.width  = 9,
  fig.align  = "center",
  cache      = FALSE
)
```

# Overview

## Motivation

Data sets commonly contain many (p>3) variables/dimensions. Numeric aggregation and modeling is scalable as the number of dimensions increase. Visualization of model and estimate-space (think residual or parallel coordinate plots) scale relatively well with dimension. Yet, visuals in data-space often fall by the wayside, especially when trying to illustrate more than 3 dimensions. If not all together abandoned, sub-optimal techniques are commonly employed.

## Alternateives

Traditionally, component analysis (PCA), correspondence analysis (CCA), or other single value decomposition (SVD) techniques have been used to approximate high dim spaces in 2 or 3-d. However doing so requires the loss of information of the discarded, transformed dimensions.

More recently stochastic neighbor embedding (t-SNE), Sammon mapping, and other non-linear transformations have seen a rise in popularity. These techniques can make astounding graphs showing distinctions and likeness across groups, but can suffer from over-fitting (potentially resulting in false groupings) and lose interoperability back to the original dimensions.

## Tourr and methodology

The R package tourr [@Cook&Wickham] provides open source tools for exploring high dim spaces that doesn't lose information and maintains dimension-interoperability. Orthonormal linear combinations of p-dimensions can be projected onto a 2-d surface and viewed as a XY scatter plot for instance. By changing the (constrained) linear combinations slightly, the 2-d projection changes in time as data are rotated in p-dimensions. Randomly selecting a dimension and direction of change is essentially the projection-pursuit method, "grand tour", originally purposed by Asimov [@Asimov et. al. 1985]. Other tours and gradient-descent indexes are discussed in the tourr package documentation hosted on CRAN, [here](https://cran.r-project.org/web/packages/tourr/tourr.pdf).

This concept can be illustrated succinctly by example. A 3-d object blocks a light source that casts a shadow onto a screen. If the object is a four-legged chair some orientations look like a black square, this conveys  little information about the shape of the object. However if the chair is rotated side or front view is seen. With continued rotation the 3-d shape can be distinguished from a 2-d animation. In the same way, information and interesting profiles describing high dimensional data can be found by watching projections of the data as it rotates.

# Code examples

## Example 1 - Rotate arbitrary basis

We'll use the flea data set. The data consists of 74 observations of 6 physical distance measurements of a flea-beetle belonging to 1 of 3 spices. This is analogous to the iris data set.

Suppose we want to perform a rotation on one dimensions of the 6-dimensional data.  

In order to rotate a dimension in p-space we need the following arguments: 

* `data`, [n, p] matrix, or data frame of numeric columns.
* `basis`, [p, d=2] matrix, a linear combination of dimensions mapping to 2-D.
* `manip_var`, name or number of the dimension to rotate.

Flea is the data we want to rotate. We initialize a random basis and then view it. Later we'll manipulate the variable 'head'.

Load the data and select a random basis with `basis_random(p)`. View the basis in p-space with `view_basis(basis, data)`, where data is optional, but adds the dimension names.

```{r}
#devtools::install_github("nspyrison/spinifex")
devtools::load_all()
#library(spinifex) #WHEN USING library(), rmd can't find spinifex functions :(
#imports ggplot2, and plotly
set.seed(123)

data <- flea[, 1:6]
p <- ncol(data)
b_rand <- create_random_basis(p = p)

view_basis(basis = b_rand, data = data)
```

<!-- I like to think of the basis as piece of paper that maps p dimension down to 2. The manipulation type (alternatively theta) is the angle of the on this basis plane between (1, 0) and the manipulation variable's vector in, our case we select 'head'. -->

<!-- In order to rotate the data object we effectively rotate this map. Imagine gluing the bottome of pen to the (0, 0) origin of the paper. By rotating the pen about the origin we rotate the whole paper.  -->

Use `proj_data()` to rotate `data` at the current orientation `basis`, by manipulating `manip_var` of the `manip` type, for a sequence of 'phi' `from` through `to` by an increment `by`.

Optionally we can specify:

* `manip_type`, "horizontal", "vertical", or "radial", controlling the the angle w.r.t. the basis' plane to rotate the variable.
* `phi_from`, the start angle to rotate the variable from, in the z direction of the basis plane.
* `Phi_to`, the end angle to rotate the variable to, in the z direction of the basis plane.
* `n_slides`, the number of increments to calculate phi between the from and to values.

Watch the projection, via `slideshow()`, coloring observations by their species.

```{r}
pal <- rainbow(length(levels(flea$species)))
col <- pal[as.numeric(flea$species)]

proj <-
  proj_data(
    data = data,
    basis = b_rand,
    manip_var = 3, # or "head"
    manip_type = "radial",
    phi_from = 0,
    phi_to = pi,
    n_slides = 20
  )
slideshow(proj, col = col)
#export()
```




<!-- ## Example 2 - Rotating a glyph map -->

<!-- ```{r} -->
<!-- #library(GGally) -->
<!-- # -->
<!-- #nasa <- nasa[nasa$date >= as.POSIXct("1998-01-01") & -->
<!-- #             nasa$lat >= 20 & -->
<!-- #             nasa$lat <= 40 & -->
<!-- #             nasa$long >= -80 & -->
<!-- #             nasa$long <= -60,  -->
<!-- #             ] #36 months of climate data.  -->
<!-- # -->
<!-- #temp.gly <- -->
<!-- #  GGally::glyphs(nasa, "long", "day", "lat", "surftemp", height = 2.5) -->
<!-- #glyph1 <- -->
<!-- #  ggplot(temp.gly, aes(gx, gy, group = gid)) + -->
<!-- #  GGally::add_ref_lines(temp.gly, color = "grey90") + -->
<!-- #  GGally::add_ref_boxes(temp.gly, color = "grey90") + -->
<!-- #  geom_path() + -->
<!-- #  theme_bw() + -->
<!-- #  labs(x = "", y = "") -->
<!-- # -->
<!-- #glyph1 -->
<!-- ``` -->


<!-- ```{r} -->
<!-- #data <- nasa[c("long", "day")] -->
<!-- #p <- ncol(data) -->
<!-- #r_basis <- create_random_basis(p = p)  -->
<!-- # -->
<!-- ###p=2 isn't working as z, will always be a linear combination of a 2x2 basis; -->
<!-- #create_manip_space goes back to 2x2 then can't perform manip_space %*%R -->
<!-- #spinifex::create_manip_space removes the new z. -->
<!-- #tourr::orthonormalise() does diag(2)||c(NaN, NaN) -->
<!-- #tourr error for p=2: Error in segments(adj(0), adj(0), adj(proj[, 1]), adj(proj[, 2]), col = "grey50") : cannot mix zero-length and non-zero-length coordinates -->

<!-- #### Do a horizontal rotation on day, changing a_2. -->
<!-- #proj_rday <- -->
<!-- #  proj_data( -->
<!-- #    data = data, -->
<!-- #    basis = r_basis, -->
<!-- #    manip_var = "day", -->
<!-- #    manip = "horizontal", -->
<!-- #    phi_from = 0, -->
<!-- #    phi_to = pi -->
<!-- #  ) -->
<!-- #slideshow(proj_rday) -->
<!-- # -->
<!-- #### Do a vertical rotation on surftemp, changing b_2. -->
<!-- #proj_rsurftemp <- -->
<!-- #  proj_data( -->
<!-- #    data = data, -->
<!-- #    basis = r_basis, -->
<!-- #    manip_var = "surftemp", -->
<!-- #    manip = "vertical", -->
<!-- #    phi_from = 0, -->
<!-- #    to = 1.88 -->
<!-- #  ) -->
<!-- #slideshow(proj_rsurftemp) -->
<!-- ``` -->



<!-- ```{r} -->
<!-- #nasa2 <- cbind( -->
<!-- #  nasa[c("long", "day", "lat", "surftemp")], -->
<!-- #  adj_day <- #x, rotated day -->
<!-- #    proj_rday$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ],  -->
<!-- #  adj_surftemp <- #y, rotated surftemp -->
<!-- #    proj_rsurftemp$proj_data[which(proj$proj_data$index==max(proj$proj_data$index)), ]  -->
<!-- #) -->
<!-- # -->
<!-- #temp.gly2 <- -->
<!-- #  GGally::glyphs(nasa2, "long", "adj_day", "lat", "adj_surftemp", height = 2.5) -->
<!-- #glyph2 <- -->
<!-- #  ggplot(temp.gly2, ggplot2::aes(gx, gy, group = gid)) + -->
<!-- #  GGally::add_ref_lines(temp.gly, color = "grey90") + -->
<!-- #  GGally::add_ref_boxes(temp.gly, color = "grey90") + -->
<!-- #  geom_path() + -->
<!-- #  theme_bw() + -->
<!-- #  labs(x = "", y = "") -->
<!-- # -->
<!-- #gridExtra::grid.arrange(glyph1, glyph2, ncol=2) -->
<!-- ``` -->



## Example 3 - Rotation after holes guided tour

```{r, results='hide'}
library(tourr)
data <- flea[, 1:6]
p <- ncol(data)

# holes is unsupervised gradient descent maximizing whitespace in the middle.
holes_tour <- 
  save_history(data, guided_tour(index = holes), max_bases = 25) 
holes_basis <-
  matrix(as.numeric(holes_tour[, , dim(holes_tour)[3]]), ncol = 2)
```


```{r}
tars1 <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "tars1",
    manip = "radial",
    phi_to = 1.57
  )
tars2 <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "tars2",
    manip = "radial",
    phi_to = 1.41
  )
head <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "head",
    manip = "radial",
    phi_to = 1.26
  )
aede1 <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "aede1",
    manip = "radial",
    phi_to = 1.41
  )
aede2 <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "aede2",
    manip = "radial",
    phi_to = 1.41
  )
aede3 <-
  proj_data(
    data = data,
    basis = holes_basis,
    manip_var = "aede3",
    manip = "radial",
    phi_to = 1.73
  )
```


```{r}
slideshow(tars1, col = col) # groups overlap when removed
slideshow(aede2, col = col) # groups overlap when removed
slideshow(tars2, col = col) # 2 groups overlap when removed
slideshow(head,  col = col) # groups still separate when removed
slideshow(aede1, col = col) # groups still separate when removed
slideshow(aede3, col = col) # groups still separate when removed
```


# Conclusion

## Summary

[RECAP WHAT PKG HELPS US DO, nanier for example:]
The tools in `naniar` help us identify where missingness is, while maintaining a tidy workflow. We care about these mechanisms or these patterns because they can help us understand potential mechanisms, such as equipment failures, and then identify possible solutions based upon this evidence.

## Namesake 

The name 'spinifex' comes from the [spinifex hopping mouse](https://en.wikipedia.org/wiki/Spinifex_hopping_mouse), a nocturnal dessert mouse common to arid zones in central and western Australia. As to it's relation to this work, in the words of Di "it spins, it hops and needs a 'mouse'."


## Acknowledgement

Thanks to Prof. Dianne Cook for focus, namesake, and the ground work underpinning this work. Thanks to Dr. Ursula Laa for use-cases and application.

## References
<!-- Monash prefers APA -->
<!-- citation(package = "tourr") -->
<!-- citation(package = "GGally") -->
- Cook, D., & Buja, A. (1997). Manual Controls for High-Dimensional Data Projections. Journal of Computational and Graphical Statistics, 6(4), 464–480. https://doi.org/10.2307/1390747
- Wickham, H., Cook, D., & Hofmann, H. (2015). Visualizing statistical models: Removing the blindfold: Visualizing Statistical Models. Statistical Analysis and Data Mining: The ASA Data Science Journal, 8(4), 203–225. https://doi.org/10.1002/sam.11271
- Dianne Cook and Hadley Wickham (NA). tourr: Implement Tour Methods in R Code. Rpackage version 0.5.5.9000. https://github.com/ggobi/tourr
- Barret Schloerke, Jason Crowley, Di Cook, Francois Briatte, Moritz Marbach,
Edwin Thoen, Amos Elberg and Joseph Larmarange (2017). GGally: Extension to
'ggplot2'. R package version 1.3.2. https://CRAN.R-project.org/package=GGally



